## [LeetCode] 94. Binary Tree Inorder Traversal

[ë¬¸ì œ í™•ì¸](https://leetcode.com/problems/binary-tree-inorder-traversal/)

-   ğŸ¤” ì™œ ë‚´ ì°½ì—ì„œëŠ” ì‹¤í–‰ì´ ì•ˆë ê¹Œ?

```js
const inorderTraversal = function (root) {
    const numbers = [];

    let inorder = function (root) {
        if (root.left) inorder(root.left);
        numbers.push(root.val);
        if (root.right) inorder(root.right);
        return;
    };
    inorder(root);
    return numbers;
};
```

<!-- FEEDBACK rootì˜ nullì— ëŒ€í•œ ì²˜ë¦¬ê°€ í•„ìš”í•©ë‹ˆë‹¤.  -->
```js
const inorderTraversal = function (root) {
    if(!root) return [];
    const numbers = [];

    let inorder = function (root) {
        if (root.left) inorder(root.left);
        numbers.push(root.val);
        if (root.right) inorder(root.right);
        return;
    };
    inorder(root);
    return numbers;
};
```

-   [ë‹¤ë¥¸ ë¶„ì˜ í’€ì´ ì°¸ê³ ](https://velog.io/@sa02045/leetcodejs-94%EB%B2%88)

```js
const inorderTraversal = function (root) {
    let output = [];
    inorderDfs(root, output);
    return output;
};

function inorderDfs(tree, output) {
    if (tree === null) {
        return;
    }
    inorderDfs(tree.left, output);
    output.push(tree.val);
    inorderDfs(tree.right, output);
}
```

-   ì¤‘ìœ„ ìˆœíšŒëŠ” ì™¼ìª½ìë…€, ë¶€ëª¨, ì˜¤ë¥¸ìª½ ìë…€ ìˆœì„œë¡œ ì¶œë ¥ëœë‹¤.

</br>
</br>

## [LeetCode] 100. Same Tree

[ë¬¸ì œ í™•ì¸](https://leetcode.com/problems/same-tree/)

-   [ë‹¤ë¥¸ ë¶„ì˜ í’€ì´ ì°¸ê³ ](https://velog.io/@lucid/LeetCode-100.-Same-Tree)

```js
const isSameTree = (p, q) => {
    if (p === null && q === null) return true;
    if ((p !== null && q === null) || (p === null && q !== null)) return false;
    if (p.val !== q.val) return false;
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
};
```

</br>
</br>

## [LeetCode] 101. Symmetric Tree

[ë¬¸ì œ í™•ì¸](https://leetcode.com/problems/symmetric-tree/)

-   [ë‹¤ë¥¸ ë¶„ì˜ í’€ì´ ì°¸ê³ ](https://ha-young.github.io/2021/algorithm_javascript/LeetCode-101_Symmetric_Tree_Lv-Easy_DFS-BFS/)

```js
var isSymmetric = function (root) {
    const leftSubTree = root.left;
    const rightSubTree = root.right;

    return checkIsMirrorTree(leftSubTree, rightSubTree);

    function checkIsMirrorTree(leftSubTree, rightSubTree) {
        // ì™¼ìª½ íŠ¸ë¦¬ì™€ ì˜¤ë¥¸ìª½ íŠ¸ë¦¬ì˜ ê°’ì´ ë‘˜ ë‹¤ ìˆëŠ”ì§€ í™•ì¸
        // ë‘˜ ë‹¤ ê°’ì´ ì—†ë‹¤ë©´ ë™ì¼í•˜ë¯€ë¡œ true return
        if (!leftSubTree && !rightSubTree) {
            return true;
        }
        // ë‘˜ ì¤‘ í•˜ë‚˜ë§Œ ìˆëŠ”ì§€ í™•ì¸
        if (leftSubTree && !rightSubTree) {
            return false;
        }

        if (rightSubTree && !leftSubTree) {
            return false;
        }
        // val ê°’ì´ ë‹¤ë¥´ë‹¤ë©´ false return
        if (leftSubTree.val !== rightSubTree.val) {
            return false;
        }

        // ì¬ê·€ë¥¼ ëŒë©´ì„œ ì™¼ìª½ íŠ¸ë¦¬ì˜ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ íŠ¸ë¦¬ì˜ ì˜¤ë¥¸ìª½ì´ ê°™ì€ì§€ í™•ì¸
        if (!checkIsMirrorTree(leftSubTree.left, rightSubTree.right)) {
            return false;
        }
        // ì™¼ìª½íŠ¸ë¦¬ì˜ ì˜¤ë¥¸ìª½ê³¼ ì˜¤ë¥¸ìª½íŠ¸ë¦¬ì˜ ì™¼ìª½ì´ ê°™ì€ì§€ í™•ì¸
        if (!checkIsMirrorTree(leftSubTree.right, rightSubTree.left)) {
            return false;
        }

        return true;
    }
};
```

```js
let isSymmetric = function (root) {
    return root == null || isMirror(root.left, root.right);
};

let isMirror = function (leftSub, rightSub) {
    if (leftSub == null && rightSub == null) return true;
    if (leftSub == null || rightSub == null) return false;
    return (
        leftSub.val == rightSub.val &&
        isMirror(leftSub.right, rightSub.left) &&
        isMirror(leftSub.left, rightSub.right)
    );
};
```
