## [LeetCode] 2389. Longest Subsequence With Limited Sum

[ë¬¸ì œ í™•ì¸](https://leetcode.com/problems/longest-subsequence-with-limited-sum/description/)

-   ê²°ê³¼: Accepted, Runtime: 134ms(Beats 53.8%), Memory: 44.4MB(Beats 76.30%)

```js
const answerQueries = function (nums, queries) {
    const sortedArr = nums.sort((a, b) => a - b);
    const findSum = (target) => {
        let sum = 0;
        let count = 0;
        for (let i = 0; i < sortedArr.length; i++) {
            // FEEDBACK: >=ì¼ ë•Œë§Œ break ê±¸ì–´ë„ ë ê²ƒê°™ë‹¤ !
            if (sum + sortedArr[i] <= target) {
                sum += sortedArr[i];
                count++;
            } else {
                break;
            }
        }

        return count;
    };

    return queries.map((ele) => findSum(ele));
};
```

</br>
</br>

## [LeetCode] 35. Search Insert Position

[ë¬¸ì œ í™•ì¸](https://leetcode.com/problems/search-insert-position/description/)

-   ê²°ê³¼: Accepted, Runtime: 61ms(Beats 93.92%), Memory: 42.3MB(Beats 36.66%)

<!-- FEEDBACK: binary-searchë¡œ í’€ê¸° !  -->
```js
const searchInsert = function (nums, target) {
    const targetIdx = nums.indexOf(target);
    if (targetIdx !== -1) return targetIdx;
    if (target < nums[0]) return 0;
    if (target > nums[nums.length - 1]) return nums.length;
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] < target && nums[i + 1] > target) {
            return i + 1;
        }
    }
};
```

<br>
<br>

## [LeetCode] 300. Longest Increasing Subsequence

[ë¬¸ì œ í™•ì¸](https://leetcode.com/problems/longest-increasing-subsequence/description/)

-   ê²°ê³¼: Wrong Answer, 16 / 54 testcases passed

<!-- FEEDBACK: ë‹¤ì‹œ í’€ê¸° -->
```js
const lengthOfLIS = function (nums) {
    // ì œì¼ ì‘ì€ ìˆ˜ì˜ ì²«ë²ˆì§¸ ì¸ë±ìŠ¤ë¥¼ ì°¾ê¸°
    // ì œì¼ í° ê°’ì˜ ë§ˆì§€ë§‰ ì¸ë±ìŠ¤ë¥¼ ì°¾ê¸°
    const minInitialIdx = nums.indexOf(Math.min(...nums));
    const max = Math.max(...nums);
    const maxLastIdx = nums.findLastIndex((ele) => ele === max);
    if (nums[minInitialIdx] === nums[maxLastIdx]) return 1;
    const slicedArr = nums.slice(minInitialIdx, maxLastIdx + 1);

    const set = new Set(slicedArr);
    const sortedSlicedArr = Array.from(set).sort((a, b) => a - b);

    const answer = [slicedArr[0]];
    let flag = 0;
    for (let i = 1; i < sortedSlicedArr.length - 1; i++) {
        const searchedIdx = slicedArr.indexOf(sortedSlicedArr[i]);
        if (searchedIdx > flag) {
            flag = searchedIdx;
            answer.push(slicedArr[searchedIdx]);
        }
    }
    answer.push(sortedSlicedArr[sortedSlicedArr.length - 1]);
    return answer;
};
```

-   ğŸ¤” ì™œ ë‚´ ë¸Œë¼ìš°ì €ì—ì„œ findLastIndex ë©”ì„œë“œê°€ ì‹¤í–‰ì´ ì•ˆë ê¹Œ
